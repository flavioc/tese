\chapter{Benchmark Programs}\label{app:code}

This appendix describes the programs used to benchmark the tabling engines
explored in this thesis. The program rules will be fully presented here and
the facts will be shortly described, because these are too big to fit here.
The author of this thesis may be contacted for the full benchmark set.

\section{Programs}

\subsubsection*{left\_first}

\begin{Verbatim}
:- table path/2.

path(X, Z) :- path(X, Y), edge(Y, Z).
path(X, Z) :- edge(X, Z).
\end{Verbatim}

\subsubsection*{left\_last}

\begin{Verbatim}
:- table path/2.

path(X, Z) :- edge(X, Z).
path(X, Z) :- path(X, Y), edge(Y, Z).
\end{Verbatim}

\subsubsection*{right\_first}

\begin{Verbatim}
:- table path/2.

path(X, Z) :- edge(X, Y), path(Y, Z).
path(X, Z) :- edge(X, Z).
\end{Verbatim}

\subsubsection*{right\_last}

\begin{Verbatim}
:- table path/2.

path(X, Z) :- edge(X, Z).
path(X, Z) :- edge(X, Y), path(Y, Z).
\end{Verbatim}

\subsubsection*{double\_last}

\begin{Verbatim}
:- table path/2.

path(X, Z) :- edge(X, Z).
path(X, Z) :- path(X, Y), path(Y, Z).
\end{Verbatim}

\subsubsection*{samegen}

\begin{Verbatim}
:- table samegen/2.

samegen(X,X).
samegen(X,Y) :- edge(W, X), samegen(W,Z), edge(Z, Y).
\end{Verbatim}

\subsubsection*{genome}

\begin{Verbatim}
:- table genome/1.
:- table path/2.

path(X, Z) :- edge(X, Z).
path(X, Z) :- path(X, Y), edge(Y, Z).

genome(X) :- path(1, X), path(2, X).
\end{Verbatim}

\subsubsection*{reach\_first}

\begin{Verbatim}   
:- table reach/2.

reach(X, Z) :- reach(X, Y), trans(Y, _, Z).
reach(X, Z) :- trans(X, _, Z).
\end{Verbatim}

\subsubsection*{reach\_last}

\begin{Verbatim}
:- table reach/2.

reach(X, Z) :- trans(X, _, Z).
reach(X, Z) :- reach(X, Y), trans(Y, _, Z).
\end{Verbatim}

\subsubsection*{flora}

\begin{Verbatim}
:- table '_$_$_flora_fd'/3.
:- table '_$_$_flora_mvd'/3.
:- table '_$_$_flora_ifd'/3.
:- table '_$_$_flora_imvd'/3.
:- table '_$_$_flora_isa'/2.
:- table '_$_$_flora_sub'/2.
:- table '_$_$_flora_fs'/3.
:- table '_$_$_flora_mvs'/3.
:- table '_$_$_flora_exists'/1.
:- table '_$_$_flora_mvd'/2.
:- table '_$_$_flora_imvd'/2.
:- table '_$_$_flora_fd_dyn'/3.
:- table '_$_$_flora_mvd_dyn'/3.
:- table '_$_$_flora_ifd_dyn'/3.
:- table '_$_$_flora_imvd_dyn'/3.
:- table '_$_$_flora_isa_dyn'/2.
:- table '_$_$_flora_sub_dyn'/2.
:- table '_$_$_flora_fs_dyn'/3.
:- table '_$_$_flora_mvs_dyn'/3.
:- table '_$_$_flora_exists_dyn'/1.
:- table '_$_$_flora_mvd_dyn'/2.
:- table '_$_$_flora_imvd_dyn'/2.

'_$_$_flora_fd'(O,M,R)   :- '_$_$_flora_fd_dyn'(O,M,R).
'_$_$_flora_mvd'(O,M,R)  :- '_$_$_flora_mvd_dyn'(O,M,R).
'_$_$_flora_ifd'(O,M,R)  :- '_$_$_flora_ifd_dyn'(O,M,R).
'_$_$_flora_imvd'(O,M,R) :- '_$_$_flora_imvd_dyn'(O,M,R).
'_$_$_flora_isa'(O1,O2)  :- '_$_$_flora_isa_dyn'(O1,O2).
'_$_$_flora_sub'(O1,O2)  :- '_$_$_flora_sub_dyn'(O1,O2).
'_$_$_flora_fs'(O,M,R)   :- '_$_$_flora_fs_dyn'(O,M,R).
'_$_$_flora_mvs'(O,M,R)  :- '_$_$_flora_mvs_dyn'(O,M,R).
'_$_$_flora_exists'(O)   :- '_$_$_flora_exists_dyn'(O).
'_$_$_flora_mvd'(O,M)    :- '_$_$_flora_mvd_dyn'(O,M).
'_$_$_flora_imvd'(O,M)   :- '_$_$_flora_imvd_dyn'(O,M).

'_$_$_flora_tag'(noquery).

?- '_$_$_flora_tag'(query), !,
   ( current_predicate('_$_$_flora_print_all'/2) ->
       true
     ;
       ( package_configuration(dir(flora),D) ->
           true
         ;
           bootstrap_package(flora,flora),
           package_configuration(dir(flora),D)
       ),
       slash(S),
       fmt_write_string(Lib,'%s%slib%sflrdisplay',f(D,S,S)),
       consult(Lib)
   ),
   !.

...
% other predicates
....
\end{Verbatim}

\subsubsection*{fib}

\begin{Verbatim}
fib(0, 1) :- !.
fib(1, 1) :- !.
fib(X, V) :-
  X > 1,
  X1 is X - 1,
  X2 is X - 2,
  fib(X1, V1),
  fib(X2, V2),
  V is V1 + V2.
     
do_fib(X) :- fib_fact(T), fib(T, X).

:- table p/2.

a(X) :- p(1,X).

p(1,2).
p(1,X) :- do_fib(X).
\end{Verbatim}

\subsubsection*{big}

\begin{Verbatim}
fib(0, 1) :- !.
fib(1, 1) :- !.
fib(X, V) :-
  X > 1,
  X1 is X - 1,
  X2 is X - 2,
  fib(X1, V1),
  fib(X2, V2),
  V is V1 + V2.
  
b(X) :- big_fact(Max), between_num(1, Max, X).

a(2) :- b(X), p(X).
a(2).
a(2) :- p(_).

p(_) :- a(_), do_fib(32).
\end{Verbatim}

\section{Facts}

\subsubsection*{chain}

A set of graph nodes in a chain configuration.

An example with 4 nodes:

\begin{Verbatim}
edge(1, 2).
edge(2, 3).
edge(3, 4).
\end{Verbatim}

\subsubsection*{cycle}

A set of graph nodes in a chain configuration, but the last node connects to the first node.

An example with four nodes:

\begin{Verbatim}
edge(1, 2).
edge(2, 3).
edge(3, 4).
edge(4, 1).
\end{Verbatim}

\subsubsection*{pyramid}

A set of graph nodes forming a pyramid configuration.

An example with four nodes (depth 2):

\begin{Verbatim}
edge(1,2).
edge(1,3).
edge(2,4).
edge(3,4).
\end{Verbatim}

\subsubsection*{tree}

A set of graph nodes forming a binary tree configuration.

An example with seven nodes (depth 3):

\begin{Verbatim}
edge(1,2).
edge(1,3).
edge(2,4).
edge(2,5).
edge(3,6).
edge(3,7).
\end{Verbatim}

\subsubsection*{grid}

A set of graph nodes forming a grid configuration.

An example with two nodes:

\begin{Verbatim}
edge(1,2).
edge(2,1).
edge(3,4).
edge(4,3).
edge(1,3).
edge(3,1).
edge(2,4).
edge(4,2).
\end{Verbatim}

\subsubsection*{leader}

Leader election specification defined for 5 processes.

\begin{Verbatim}
% the transition relation graph trans(par(A,end,end,B),nop,B).
trans(par(A,B,C,D),E,par(A,F,G,D)) :-
   (partrans(A,E,B,C,F,G);partrans(A,E,C,B,G,F)).
trans(medium_0(A,B,C,D),
   in(A,E),medium_0(A,B,[E|C],D)).
...
% auxiliary predicates
...
\end{Verbatim}

\subsubsection*{sieve}

Sieve specification defined for 5 processes and 4 overflow prime numbers.

\begin{Verbatim}
% the transition relation graph trans(par(A,end,end,B),nop,B).
trans(par(A,B,C,D),E,par(A,F,G,D)) :-
   (partrans(A,E,B,C,F,G);partrans(A,E,C,B,G,F)).
trans(generator_0(A,B,C,D),out(A,B),D) :-
   E is B+1, not B=<C.
...
% auxiliary predicates
...
\end{Verbatim}

\subsubsection*{iproto}

Specification for the i-protocol defined for a correct version with a huge window size.

\begin{Verbatim}
fixed(fix).

% the transition relation graph trans(par(A,end,end,B),nop,B).
trans(par(A,B,C,D),E,par(A,F,G,D)) :-
   (partrans(A,E,B,C,F,G);partrans(A,E,C,B,G,F)). 
trans(iproto_0(A,B,C),nop,imain_0(C)).
...
% auxiliary predicates
...
\end{Verbatim}