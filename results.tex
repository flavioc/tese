This chapter presents a detailed performance analysis of the two subsumption-based tabling engines
that we have developed. We divided this chapter into four sections. The first section describes the
set of tabled benchmark programs that we have used to assess the performance of execution. The second
section evaluates the engine with traditional call subsumption that was implemented by integrating the
Time-Stamped Tries algorithms and data structures from XSB into Yap. In the next section, we evaluate
the retroactive-based tabling engine for programs that do not benefit from the new mechanisms and
for programs that take advantage of the new evaluation method. The final, and fourth, section describes
the advantages and disadvantages of the three engines, variant, subsumptive or retroactive to
compute the the reachability between two nodes in a graph.

\section{Benchmark Programs}

In order to assess the performance of our tabling engines we used various programs and data sets.
The following list describes the programs used:

\begin{description}
   
   \item[path:] The \texttt{path/2} program computes the reachability between two nodes in a graph.
   Connections between two nodes are represented by \texttt{edge/2} facts.
   We used the following graph configurations in our tests: \textbf{tree}, graph is a
   binary tree; \textbf{chain}, graph is chain of nodes; \textbf{cycle}, graph is a chain, but
   last node on the chain connects with the first node; \textbf{pyramid}, a pyramid configuration;
   and \textbf{grid}, where nodes are connected in a grid-like fashion.
   For the \texttt{path/2} program itself, we used 6 different versions: \texttt{path\_left\_first},
   \texttt{path\_left\_last}, \texttt{path\_right\_first}, \texttt{path\_right\_last},
   \texttt{path\_double\_first}, and \texttt{path\_double\_last}.
    
   \item[samegen:] The \texttt{samegen/2} predicate solves the same generation problem.
   For this test, we used the same data sets of the \texttt{path/2} program.
   
   \item[genome:] This program computes the set of nodes that are reached by node 1 and node 2.
   This is an interesting problem, since it creates lots of subsumed consumers when using
   call subsumption. We also used the same data sets of the \texttt{path/2} program.
   To compute reachability this program uses the \texttt{path\_left\_last} program.
   
   \item[reach:] The \texttt{reach/2} computes the reachability in a relation graph for a set of
   specifications. The benchmark is actually a set of programs originally taken from the
   XMC project~\cite{system-xmc,RamakrishnanCR-00}, which is a model checker implemented
   atop the XSB system. We used two variants of the \texttt{reach/2} predicate,
   \texttt{reach\_left\_first} and \texttt{reach\_left\_last}.
   The following relation graphs are used:
   
      \begin{description}
         
         \item[sieve:] \emph{sieve} specification defined for 5 processes and 4 overflow prime numbers.
         
         \item[leader:] \emph{leader election} specification defined for 5 processes.
         
         \item[iproto:] \emph{i-protocol} specification defined for a correct version with a huge window size.

      \end{description}
\end{description}

Note that the code for these programs is presented in Appendix~\ref{app:code}.

In the next tables, execution time is measured in milliseconds and all benchmarks
are executed to find all solutions for the problem at hand. The scheduling strategy used
by default is batched scheduling.
The environment for our experiments was an Intel Core(TM) 2 Quad 2.66 GHz with 4 GBytes of
memory and running the Linux kernel 2.6.31 with YapTab 6.0.3 and XSB Prolog 3.2.

\section{Performance Evaluation for YapTab\_TST}

In order to evaluate the YapTab\_TST tabling engine we used the following programs:

\begin{itemize}
   \item The \texttt{path/2} program with the query `\texttt{?-~path(X,Y)}' with all the combinations of
   versions and data sets.
   \item The \texttt{genome/1} program with different data sets. The query used was `\texttt{?-~genome(X)}'.
   
   \item The query `\texttt{?-~samegen(X,Y)}' in the \texttt{samegen/2} program. All \texttt{path/2} data
   sets were used.
   
   \item The two versions of the \texttt{reach/2} program with the following queries for the relation graphs:

   \begin{itemize}
      \item sieve: `\texttt{?-~reach(sieve\_0(5,4,27,end),Y)}'.
      \item leader: `\texttt{?-~reach(systemLeader\_0(5,end),Y)}'.
      \item iproto: `\texttt{?-~reach(iproto\_0(\_,\_,end),Y)}'.
   \end{itemize}

\end{itemize}

We compared the performance of the SLG-WAM and YapTab with traditional call subsumption.
For each benchmark, we used variant-based tabling and then subsumption-based tabling.
Next, we compared the values of each engine and calculated the speedup ($T_{variant} / T_{subsumptive}$) for
each engine. Given that YapTab\_TST uses a great deal of code from XSB to implement the subsumption mechanisms,
we expect the speedups to be very similar. Some potential differences between them will arise because
of certain characteristics, namely: the way they implement the tabling algorithms, the WAM engine itself,
the compiled trie code, and the handling of answer templates.

Tables \ref{tbl:result_path_left_first},
\ref{tbl:result_path_left_last},
\ref{tbl:result_path_right_first},
\ref{tbl:result_path_right_last},
\ref{tbl:result_path_double_first},
\ref{tbl:result_path_double_last},
\ref{tbl:result_samegen},
\ref{tbl:result_genome},
\ref{tbl:result_reach_left_first},
and \ref{tbl:result_reach_left_last} show the performance tests for SLG-WAM and YapTab.
The first thing we note is that, in 4 benchmarks (Tables \ref{tbl:result_path_left_first},
\ref{tbl:result_path_left_last}, \ref{tbl:result_path_right_last} and \ref{tbl:result_genome})
YapTab has a better speedup than SLG-WAM, while in 6 of them SLG-WAM wins. While SLG-WAM wins here,
the speedups for the two engines are very similar, which proves that our integration
efforts of the Time-Stamped Tries approach to subsumption-based tabling in YapTab was largely successful.
There is one benchmark were this observation does not hold, which is the \texttt{samegen}
benchmark (Table~\ref{tbl:result_samegen}).
The SLG-WAM engine has a speedup of 201.722 and YapTab only 1.868 because the performance
of the variant-based version of SLG-WAM performs very poorly against YapTab which explains such big differences.

The programs \texttt{path\_left\_first} and \texttt{path\_left\_last} (Tables~\ref{tbl:result_path_left_first}
and \ref{tbl:result_path_left_last}) do not generate any subsumed consumer,
therefore they are good benchmarks to assess the overhead of using subsumption mechanisms. For YapTab,
the overhead is minimal with a speedup of 0.998 for the \texttt{path\_left\_first}. Surprisingly, for the
\texttt{path\_left\_last} program the speedup is bigger than 1. SLG-WAM has more overhead, with 0.775 and 0.765.

The programs \texttt{path\_right\_first} and \texttt{path\_right\_last} do generate subsumed consumers,
as many as \texttt{edge/2} facts. Notably, only the SLG-WAM with the \texttt{path\_right\_first} program
achieves a speedup bigger than 1. Why there are no speedups for these programs is that simple facts
are faster to evaluate than to use the time stamped trie to collect relevant answers.

For the \texttt{path\_double\_first} and \texttt{path\_double\_last} (Tables~\ref{tbl:result_path_double_first}
and \ref{tbl:result_path_double_last}) we have attained speedups over 1.2-1.3
for each configuration. These benchmarks are more computationally expensive given that they create more
dependencies. These dependencies diminish in subsumption-based tabling because only new consumers are created
and code is not executed.

The \texttt{genome} program (Table~\ref{tbl:result_genome}) attained very good speedup results, with
389.905 for YapTab. In this program, the subgoal \texttt{path(2,X)} and \texttt{path(1,X)} are called
very early in the evaluation and further subgoals calls to \texttt{path/2} that are subsumed by these
goals are consumers.

For the model checking programs (Tables \ref{tbl:result_reach_left_first} and \ref{tbl:result_reach_left_last}),
the results were not so good for subsumption-based evaluation with identical speedups for YapTab and SLG-WAM.

\input{tables_path}

\input{tables_model_checking}

\section{Performance Evaluation for RCS}

\input{tables_retro_overhead}

\input{tables_retro_overhead_model}
